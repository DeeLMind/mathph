import{_ as i,K as a,L as l,a5 as n,W as e,F as s}from"./framework-edebdfe1.js";const r={},c=e(`<h1 id="汇编指令" tabindex="-1"><a class="header-anchor" href="#汇编指令" aria-hidden="true">#</a> 汇编指令</h1><h2 id="基础指令" tabindex="-1"><a class="header-anchor" href="#基础指令" aria-hidden="true">#</a> 基础指令</h2><ul><li><code>PUSH</code></li></ul><div class="language-JS line-numbers-mode" data-ext="JS"><pre class="language-JS"><code>PUSH X (将操作数X推入栈顶)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li><code>POP</code></li></ul><div class="language-JS line-numbers-mode" data-ext="JS"><pre class="language-JS"><code>POP X (将栈顶的操作数弹出到X)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li><code>MOV</code></li></ul><div class="language-JS line-numbers-mode" data-ext="JS"><pre class="language-JS"><code>MOV A,B (将操作数B推入操作数A)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li><code>LEA</code></li></ul><div class="language-JS line-numbers-mode" data-ext="JS"><pre class="language-JS"><code>LEA A,B (地址操作，将操作数B推入操作数A Load Effective Address)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li><code>MOVQ</code></li></ul><div class="language-JS line-numbers-mode" data-ext="JS"><pre class="language-JS"><code>MOVQ A,B (将操作数B推入操作数A,QuaDword)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li><code>SUB</code></li></ul><div class="language-JS line-numbers-mode" data-ext="JS"><pre class="language-JS"><code>SUB DESTINATION,SOURCE (两个操作数相减操作，并将结果存放在目的操作数中)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li><code>ADD</code></li></ul><div class="language-JS line-numbers-mode" data-ext="JS"><pre class="language-JS"><code>ADD DESTINATION,SOURCE (两个操作数相加操作，并将结果存放在目的操作数中)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,16),u=e(`<h2 id="函数调用" tabindex="-1"><a class="header-anchor" href="#函数调用" aria-hidden="true">#</a> 函数调用</h2><ul><li><code>CALL</code></li></ul><div class="language-JS line-numbers-mode" data-ext="JS"><pre class="language-JS"><code>CALL FUNCTION (调用函数)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li><code>RET</code></li></ul><div class="language-JS line-numbers-mode" data-ext="JS"><pre class="language-JS"><code>RET(N) X (函数返回，返回值放入EAX)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="位与操作" tabindex="-1"><a class="header-anchor" href="#位与操作" aria-hidden="true">#</a> 位与操作</h2><ul><li><code>AND</code></li></ul><div class="language-JS line-numbers-mode" data-ext="JS"><pre class="language-JS"><code>AND DESTINATION,SOURCE (两个操作数的对应位之间进行（按位）逻辑与（AND）操作，并将结果存放在目的操作数中，会操作标志位)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li><code>XOR</code></li></ul><div class="language-JS line-numbers-mode" data-ext="JS"><pre class="language-JS"><code>XOR DESTINATION,SOURCE (两个操作数的对应位之间进行（按位）逻辑与（XOR）操作，并将结果存放在目的操作数中，当按位操作或算术操作的目标操作数最低字节为偶时，奇偶标志PF位置 1，反之，如果操作数为奇校验，则奇偶标志位清 0)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="比较指令" tabindex="-1"><a class="header-anchor" href="#比较指令" aria-hidden="true">#</a> 比较指令</h2><ul><li><code>CMP</code></li></ul><div class="language-JS line-numbers-mode" data-ext="JS"><pre class="language-JS"><code>Compare WITH
CMP DESTINATION,SOURCE (比较，目的操作数中减去源操作数，赋值给目的操作数)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><table><thead><tr><th>CMP结果</th><th>ZF</th><th>CF</th></tr></thead><tbody><tr><td>目的操作数 &lt; 源操作数</td><td>0</td><td>1</td></tr><tr><td>目的操作数 &gt; 源操作数</td><td>0</td><td>0</td></tr><tr><td>目的操作数 = 源操作数</td><td>1</td><td>0</td></tr></tbody></table><ul><li><code>TEST</code></li></ul><div class="language-JS line-numbers-mode" data-ext="JS"><pre class="language-JS"><code>TEST DESTINATION,SOURCE (两个操作数的对应位之间进行 AND 操作，并根据运算结果设置符号标志位、零标志位和奇偶标志位)

0  0  1  0  0  1  0  1    &lt;- 输入值
0  0  0  0  1  0  0  1    &lt;- 测试值
0  0  0  0  0  0  0  1    &lt;- 结果：ZF=0

0  0  1  0  0  1  0  0    &lt;- 输入值
0  0  0  0  1  0  0  1    &lt;- 测试值
0  0  0  0  0  0  0  0    &lt;- 结果：ZF=1
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="跳转指令" tabindex="-1"><a class="header-anchor" href="#跳转指令" aria-hidden="true">#</a> 跳转指令</h2><ul><li><code>JMP</code></li></ul><div class="language-JS line-numbers-mode" data-ext="JS"><pre class="language-JS"><code>Always jump
JMP DESTINATION (JUMP 无条件跳转)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>JE</code></li></ul><div class="language-JS line-numbers-mode" data-ext="JS"><pre class="language-JS"><code>Jump if cmp is equal
JE DESTINATION (判断ZF标志位，如果ZF=1则跳转，如果ZF=0，不跳转)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>JNE</code></li></ul><div class="language-JS line-numbers-mode" data-ext="JS"><pre class="language-JS"><code>Jump if cmp is equal
JE DESTINATION (判断ZF标志位，如果ZF=0则跳转，如果ZF=1，不跳转)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div>`,23);function t(v,o){const d=s("DocsAD");return a(),l("div",null,[c,n(d),u])}const b=i(r,[["render",t],["__file","op.html.vue"]]);export{b as default};
