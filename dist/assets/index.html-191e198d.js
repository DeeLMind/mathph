import{_ as l,K as a,L as n,a5 as r,W as i,F as t}from"./framework-edebdfe1.js";const o={},c=i('<h1 id="漏洞挖掘" tabindex="-1"><a class="header-anchor" href="#漏洞挖掘" aria-hidden="true">#</a> 漏洞挖掘</h1><div class="hint-container warning"><p class="hint-container-title">DeeLMind 提示</p><p>漏洞挖掘，主要指二进制漏洞挖掘，本质就是逆向分析，WEB漏洞不在此，因此漏洞挖掘需要很强的二进制基础。</p></div><h2 id="漏洞类型" tabindex="-1"><a class="header-anchor" href="#漏洞类型" aria-hidden="true">#</a> 漏洞类型</h2><ul><li>栈溢出漏洞（Stack-Overflow）</li><li>堆溢出漏洞（Heap-Overflow）</li><li>释放后重引用漏洞（Use-After-Free）</li><li>双重释放漏洞（Double-Free）</li><li>越界访问漏洞（Out-of-Bounds)</li><li>字符串格式化漏洞（Format-String）</li></ul>',4),d=i('<h2 id="漏洞挖掘工具" tabindex="-1"><a class="header-anchor" href="#漏洞挖掘工具" aria-hidden="true">#</a> 漏洞挖掘工具</h2><ul><li>FUZZ工具</li><li>AFL++</li><li>WinAFL</li><li>调试工具</li></ul><h2 id="编译保护" tabindex="-1"><a class="header-anchor" href="#编译保护" aria-hidden="true">#</a> 编译保护</h2><ul><li>GS 缓存区检查</li><li>PIE（ASLR）</li><li>CANNARY(栈保护)</li><li>FORTIFY</li><li>NX（DEP）</li><li>RELRO</li><li>PIE</li></ul>',4);function s(h,u){const e=t("DocsAD");return a(),n("div",null,[c,r(e),d])}const f=l(o,[["render",s],["__file","index.html.vue"]]);export{f as default};
