import{_ as e,K as t,L as p,M as n,N as s,a5 as o,W as i,F as c}from"./framework-fa417d66.js";const l={},u=n("h1",{id:"前缀篡改攻击",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#前缀篡改攻击","aria-hidden":"true"},"#"),s(" 前缀篡改攻击")],-1),r={href:"https://github.com/elikaski/ECC_Attacks",target:"_blank",rel:"noopener noreferrer"},d=i(`<h2 id="攻击原理" tabindex="-1"><a class="header-anchor" href="#攻击原理" aria-hidden="true">#</a> 攻击原理：</h2><p>前缀篡改攻击（Prefix Collision Attack）在签名过程中，通常的做法是先对消息进行哈希处理，然后将哈希值的高位部分用于签名。这个哈希步骤的作用是将消息压缩成固定长度，并且确保签名只能对应特定的消息内容。如果跳过哈希步骤，直接用消息的原始内容来计算签名（如示例代码中所做的那样），攻击者就能在不修改签名的情况下篡改消息内容。</p><p>具体来说，在这种情况下，签名仅仅是基于消息的开头部分（即消息的前缀）。因此，攻击者可以修改消息的后续部分，而不影响签名的有效性，只要消息的开头部分与原始消息一致，签名就会继续有效。这就会导致签名无法正确保证消息的完整性。</p><h2 id="攻击后果" tabindex="-1"><a class="header-anchor" href="#攻击后果" aria-hidden="true">#</a> 攻击后果：</h2><p>这种攻击方式的后果可能非常严重，尤其是在金融交易或敏感数据处理的场景中。攻击者能够篡改消息的内容（例如转账金额或收款方）而不需要知道私钥，签名仍然是有效的，这可能导致资金的错误转账或其他恶意行为。</p><h2 id="防范措施" tabindex="-1"><a class="header-anchor" href="#防范措施" aria-hidden="true">#</a> 防范措施：</h2><p>为了避免这种攻击，签名过程中的哈希步骤不可省略，应该对消息进行完整的哈希处理后再进行签名。这样，即使攻击者改变消息的后半部分，签名也会失效，因为哈希值会完全改变，无法匹配原始签名。</p><p>另外，使用标准的签名方案（如带有严格哈希处理的ECDSA或RSA）来确保消息的完整性和签名的不可篡改性，也可以有效防止此类攻击。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">from</span> ecdsa <span class="token keyword">import</span> SigningKey<span class="token punctuation">,</span> NIST256p

<span class="token comment"># 创建签名和验证的密钥</span>
signing_key <span class="token operator">=</span> SigningKey<span class="token punctuation">.</span>generate<span class="token punctuation">(</span>NIST256p<span class="token punctuation">)</span>
verifying_key <span class="token operator">=</span> signing_key<span class="token punctuation">.</span>verifying_key

<span class="token comment"># 自定义的哈希函数（不进行实际哈希，直接返回原始数据）</span>
<span class="token keyword">class</span> <span class="token class-name">MyHash</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>data <span class="token operator">=</span> data

    <span class="token keyword">def</span> <span class="token function">digest</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>data

<span class="token comment"># 签名消息并验证签名</span>
message <span class="token operator">=</span> <span class="token string">&quot;Please transfer 1,000$ to GitHub&quot;</span>
signature <span class="token operator">=</span> signing_key<span class="token punctuation">.</span>sign<span class="token punctuation">(</span>message<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hashfunc<span class="token operator">=</span>MyHash<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>verifying_key<span class="token punctuation">.</span>verify<span class="token punctuation">(</span>signature<span class="token punctuation">,</span> message<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hashfunc<span class="token operator">=</span>MyHash<span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment"># 构造恶意消息并验证原始消息的签名是否仍然有效</span>
evil_message <span class="token operator">=</span> <span class="token string">&quot;Please transfer 1,000$ to GitHub and 1,000,000$ to Eli Kaski&quot;</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>verifying_key<span class="token punctuation">.</span>verify<span class="token punctuation">(</span>signature<span class="token punctuation">,</span> evil_message<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hashfunc<span class="token operator">=</span>MyHash<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,9);function k(v,m){const a=c("ExternalLinkIcon");return t(),p("div",null,[u,n("p",null,[n("a",r,[s("https://github.com/elikaski/ECC_Attacks"),o(a)])]),d])}const f=e(l,[["render",k],["__file","PrefixCollisionAttack.html.vue"]]);export{f as default};
