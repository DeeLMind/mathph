import{_ as a,K as e,L as t,a5 as o,M as n,N as p,W as c,F as l}from"./framework-fa417d66.js";const i={},r=n("h1",{id:"同态加密",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#同态加密","aria-hidden":"true"},"#"),p(" 同态加密")],-1),u=n("p",null,"同态加密（Homomorphic Encryption）是一种加密方式，允许对密文进行操作而无需解密，且结果解密后与直接对明文进行相同操作的结果一致。换句话说，同态加密使得对加密数据进行计算变得可能，而不需要访问或暴露原始数据。这一特性在许多隐私保护计算场景中非常重要，例如隐私计算、云计算和安全多方计算等。",-1),d=c(`<h2 id="同态加密的类型" tabindex="-1"><a class="header-anchor" href="#同态加密的类型" aria-hidden="true">#</a> 同态加密的类型</h2><p>同态加密可以分为以下几种类型：</p><ol><li><p><strong>部分同态加密（Partially Homomorphic Encryption，PHE）</strong>：只支持某一类操作，比如加法或乘法。</p><ul><li>例如，RSA和ElGamal就是部分同态加密算法，RSA支持加法同态，而ElGamal支持乘法同态。</li></ul></li><li><p><strong>全同态加密（Fully Homomorphic Encryption，FHE）</strong>：支持任意的加法和乘法操作，可以进行复杂的计算。</p><ul><li>比如Gentry提出的全同态加密方案。</li></ul></li><li><p><strong>一些同态加密（Somewhat Homomorphic Encryption，SHE）</strong>：支持有限次数的加法和乘法操作。</p></li></ol><h2 id="同态加密的工作原理" tabindex="-1"><a class="header-anchor" href="#同态加密的工作原理" aria-hidden="true">#</a> 同态加密的工作原理</h2><p>同态加密的基本思想是，数据在加密后仍然可以执行计算，并且计算结果可以解密得到正确的答案。这个过程通常包括以下几个步骤：</p><ol><li><strong>加密</strong>：将明文数据通过加密算法转换成密文。</li><li><strong>计算</strong>：在密文上执行某些操作（加法、乘法等）。</li><li><strong>解密</strong>：将计算后的密文结果解密，得到最终结果。</li></ol><h2 id="同态加密的具体例子" tabindex="-1"><a class="header-anchor" href="#同态加密的具体例子" aria-hidden="true">#</a> 同态加密的具体例子</h2><p>假设我们有两个明文数字 <code>a = 3</code> 和 <code>b = 5</code>，并希望计算它们的加法和乘法，同时保持隐私。</p><h3 id="加密过程" tabindex="-1"><a class="header-anchor" href="#加密过程" aria-hidden="true">#</a> 加密过程</h3><p>假设我们使用一种简单的同态加密方案（例如加法同态加密），我们将 <code>a</code> 和 <code>b</code> 分别加密成 <code>Enc(a)</code> 和 <code>Enc(b)</code>。</p><p>由于加密算法的具体细节依赖于加密库的实现，具体的加密过程我们可以略过，但可以假设我们得到了加密后的密文 <code>Enc(a)</code> 和 <code>Enc(b)</code>。</p><h3 id="密文操作" tabindex="-1"><a class="header-anchor" href="#密文操作" aria-hidden="true">#</a> 密文操作</h3><p>由于同态加密允许对密文进行操作，我们可以直接对加密后的数据执行加法和乘法。</p><ul><li>对密文进行加法：<code>Enc(a) + Enc(b)</code>（结果是加密后的和）。</li><li>对密文进行乘法：<code>Enc(a) * Enc(b)</code>（结果是加密后的积）。</li></ul><h3 id="解密过程" tabindex="-1"><a class="header-anchor" href="#解密过程" aria-hidden="true">#</a> 解密过程</h3><p>最后，我们将加密的结果解密得到明文的计算结果。</p><ul><li>解密加法结果：<code>Dec(Enc(a) + Enc(b)) = a + b = 8</code>。</li><li>解密乘法结果：<code>Dec(Enc(a) * Enc(b)) = a * b = 15</code>。</li></ul><h2 id="同态加密的应用场景" tabindex="-1"><a class="header-anchor" href="#同态加密的应用场景" aria-hidden="true">#</a> 同态加密的应用场景</h2><ol><li><p><strong>隐私计算</strong>：在不泄露数据内容的前提下对加密数据进行处理。例如，在医疗数据分析中，医院可以将患者的敏感信息加密后交给第三方进行分析，第三方可以对加密数据进行计算，最后返回结果给医院，而无需查看患者的私人数据。</p></li><li><p><strong>安全云计算</strong>：用户可以将加密数据存储在云端，云服务器可以在不解密的情况下处理数据并返回结果，避免数据泄露的风险。</p></li><li><p><strong>分布式计算</strong>：通过同态加密，可以在多个不信任的方之间进行计算，而无需担心中间方查看或篡改数据。</p></li></ol><h2 id="同态加密的挑战与发展" tabindex="-1"><a class="header-anchor" href="#同态加密的挑战与发展" aria-hidden="true">#</a> 同态加密的挑战与发展</h2><ol><li><strong>计算开销大</strong>：同态加密特别是全同态加密，目前的计算开销远高于常规加密，仍然是一个难题。</li><li><strong>效率提升</strong>：近年来，很多研究人员致力于提高同态加密的计算效率，减少延迟和资源消耗。</li><li><strong>应用限制</strong>：同态加密目前尚未广泛应用于所有领域，尤其是大规模数据处理和实时计算场景，还需要进一步优化。</li></ol><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">import</span> tenseal <span class="token keyword">as</span> ts

<span class="token comment"># Setup TenSEAL context</span>
context <span class="token operator">=</span> ts<span class="token punctuation">.</span>context<span class="token punctuation">(</span>
            ts<span class="token punctuation">.</span>SCHEME_TYPE<span class="token punctuation">.</span>CKKS<span class="token punctuation">,</span>
            poly_modulus_degree<span class="token operator">=</span><span class="token number">8192</span><span class="token punctuation">,</span>
            coeff_mod_bit_sizes<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">60</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">60</span><span class="token punctuation">]</span>
          <span class="token punctuation">)</span>
context<span class="token punctuation">.</span>generate_galois_keys<span class="token punctuation">(</span><span class="token punctuation">)</span>
context<span class="token punctuation">.</span>global_scale <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">**</span><span class="token number">40</span>

v1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span>
v2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span>

<span class="token keyword">print</span><span class="token punctuation">(</span>v1<span class="token punctuation">,</span>v2<span class="token punctuation">)</span>

<span class="token comment"># encrypted vectors</span>
enc_v1 <span class="token operator">=</span> ts<span class="token punctuation">.</span>ckks_vector<span class="token punctuation">(</span>context<span class="token punctuation">,</span> v1<span class="token punctuation">)</span>
enc_v2 <span class="token operator">=</span> ts<span class="token punctuation">.</span>ckks_vector<span class="token punctuation">(</span>context<span class="token punctuation">,</span> v2<span class="token punctuation">)</span>

<span class="token keyword">print</span><span class="token punctuation">(</span>enc_v1<span class="token punctuation">,</span>enc_v2<span class="token punctuation">)</span>

result <span class="token operator">=</span> enc_v1 <span class="token operator">+</span> enc_v2
v3 <span class="token operator">=</span> result<span class="token punctuation">.</span>decrypt<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># ~ [4, 4, 4, 4, 4]</span>

<span class="token keyword">print</span><span class="token punctuation">(</span>v3<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,22);function k(v,m){const s=l("DocsAD");return e(),t("div",null,[r,u,o(s),d])}const b=a(i,[["render",k],["__file","he.html.vue"]]);export{b as default};
