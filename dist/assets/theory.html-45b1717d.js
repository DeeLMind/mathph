import{_ as o,K as r,L as c,a5 as a,M as s,N as e,W as n,F as i}from"./framework-edebdfe1.js";const p="/imgs/web3/btc/transactions.svg",h="/imgs/web3/btc/timestamp-server.svg",m="/imgs/web3/btc/proof-of-work.svg",d="/imgs/web3/btc/reclaiming-disk-space.svg",u="/imgs/web3/btc/simplified-payment-verification.svg",g="/imgs/web3/btc/combining-splitting-value.svg",y="/imgs/web3/btc/privacy.svg",b={},f=n('<h1 id="btc原理" tabindex="-1"><a class="header-anchor" href="#btc原理" aria-hidden="true">#</a> BTC原理</h1><h2 id="比特币单位" tabindex="-1"><a class="header-anchor" href="#比特币单位" aria-hidden="true">#</a> 比特币单位</h2><ol><li>比特币（BTC）</li><li>毫比特币（mBTC）</li><li>微比特币（μBTC）</li><li>聪（Satoshi）</li></ol><h2 id="psbt" tabindex="-1"><a class="header-anchor" href="#psbt" aria-hidden="true">#</a> PSBT</h2><p>PSBT (Partially Signed Bitcoin Transaction) 是一种比特币交易的标准格式，允许交易的部分签名，以便在多个参与方之间协作签署交易，尤其在多重签名 (multisig) 和硬件钱包场景中非常实用。</p>',5),v=n(`<h2 id="utxo-unspent-transaction-output-模型" tabindex="-1"><a class="header-anchor" href="#utxo-unspent-transaction-output-模型" aria-hidden="true">#</a> UTXO (Unspent Transaction Output) 模型</h2><p>UTXO 模型是一种区块链系统中的交易模型，用于跟踪比特币等加密货币的所有权。每笔交易都会产生一个或多个 UTXO，表示尚未花费的比特币输出。</p><h3 id="_1-utxo-模型的特点" tabindex="-1"><a class="header-anchor" href="#_1-utxo-模型的特点" aria-hidden="true">#</a> 1. UTXO 模型的特点</h3><ul><li><strong>去中心化</strong>：通过全网节点追踪每个交易的状态，确保系统的去中心化特性。</li><li><strong>不可变性</strong>：每个 UTXO 一旦被创建，它的状态在被花费前不会发生变化。</li><li><strong>隐私性</strong>：UTXO 模型中每次交易的输入和输出地址可以不重复使用，提升交易隐私。</li><li><strong>并行性</strong>：多个 UTXO 可以被不同的交易同时使用，允许更高的并行度。</li></ul><h3 id="_2-utxo-交易流程" tabindex="-1"><a class="header-anchor" href="#_2-utxo-交易流程" aria-hidden="true">#</a> 2. UTXO 交易流程</h3><p>假设小明第一次收到30 BTC，然后又接收了10 BTC，现在需要支付5 BTC。</p><ul><li>UTXO1：30 BTC（来自第一次接收）</li><li>UTXO2：10 BTC（来自第二次接收）</li></ul><p>小明现在需要支付5 BTC，他的钱包将自动选择足够的UTXO来满足支付金额。通常，钱包会选择较小的UTXO来减少找零或更高效率。在这个例子中，钱包可能选择UTXO2（10 BTC）来支付5 BTC。</p><ul><li>输入：UTXO2：10 BTC</li><li>输出：支付给接收者：5 BTC ，找零给小明：5 BTC（新的UTXO）</li></ul><p>UTXO2被完全使用，支付完5 BTC后，剩下的5 BTC会作为找零，生成一个新的UTXO，返还给小明。</p><p>交易确认后的UTXO状态：</p><ul><li>UTXO1：30 BTC（未动）</li><li>UTXO3：5 BTC（新的找零UTXO）</li></ul><h2 id="比特币中的utxo脚本" tabindex="-1"><a class="header-anchor" href="#比特币中的utxo脚本" aria-hidden="true">#</a> 比特币中的UTXO脚本</h2><p>在比特币中，UTXO（未花费交易输出）脚本是实现交易验证和条件支付的一种机制。每个UTXO不仅包含发送者和接收者的地址，还包含一段脚本，这段脚本定义了如何使用该输出。</p><h3 id="_1-脚本类型" tabindex="-1"><a class="header-anchor" href="#_1-脚本类型" aria-hidden="true">#</a> 1. 脚本类型</h3><p>比特币使用一种称为脚本语言的简单编程语言来定义交易输出的花费条件。常见的脚本类型包括：</p><ul><li><p><strong>P2PKH（Pay to Public Key Hash）</strong>：</p><ul><li>最常用的脚本类型，输出是支付给一个公钥哈希（地址）。</li><li>脚本示例：<div class="language-plaintext line-numbers-mode" data-ext="plaintext"><pre class="language-plaintext"><code>OP_DUP OP_HASH160 &lt;pubKeyHash&gt; OP_EQUALVERIFY OP_CHECKSIG
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li>要花费此输出，用户必须提供相应的公钥和签名。</li></ul></li><li><p><strong>P2SH（Pay to Script Hash）</strong>：</p><ul><li>支持复杂的脚本，如多重签名。</li><li>输出是支付给一个脚本哈希。</li><li>脚本示例：<div class="language-plaintext line-numbers-mode" data-ext="plaintext"><pre class="language-plaintext"><code>OP_HASH160 &lt;scriptHash&gt; OP_EQUAL
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li>花费时，用户需要提供原始脚本及其满足条件的签名。</li></ul></li><li><p><strong>P2WPKH（Pay to Witness Public Key Hash）</strong>：</p><ul><li>用于比特币隔离见证（Segregated Witness）交易。</li><li>脚本示例：<div class="language-plaintext line-numbers-mode" data-ext="plaintext"><pre class="language-plaintext"><code>OP_0 &lt;witnessPubKeyHash&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li>提供更低的交易费用和更好的隐私。</li></ul></li></ul><h3 id="_2-脚本结构" tabindex="-1"><a class="header-anchor" href="#_2-脚本结构" aria-hidden="true">#</a> 2. 脚本结构</h3><p>每个UTXO包含两个脚本：</p><ul><li><strong>锁定脚本（Locking Script）</strong>：定义如何花费该输出（即花费条件）。</li><li><strong>解锁脚本（Unlocking Script）</strong>：在创建交易时提供，满足锁定脚本的条件。</li></ul><h3 id="_3-脚本执行" tabindex="-1"><a class="header-anchor" href="#_3-脚本执行" aria-hidden="true">#</a> 3. 脚本执行</h3><p>当用户尝试花费一个UTXO时，比特币节点会执行脚本以验证交易的有效性。执行过程如下：</p><ul><li>将解锁脚本和锁定脚本合并。</li><li>按照比特币脚本语言的规则执行，使用栈来存储中间结果。</li><li>如果最终栈中的结果是布尔值<code>true</code>，则交易有效，UTXO可以被消费。</li></ul><h3 id="_4-安全性与复杂性" tabindex="-1"><a class="header-anchor" href="#_4-安全性与复杂性" aria-hidden="true">#</a> 4. 安全性与复杂性</h3><ul><li><strong>安全性</strong>：通过脚本机制，比特币确保只有满足条件的用户才能花费特定的UTXO，增强了安全性。</li><li><strong>复杂性</strong>：虽然脚本提供了灵活性，但复杂的脚本可能导致更高的交易费用和验证成本。</li></ul><h2 id="比特币地址类型" tabindex="-1"><a class="header-anchor" href="#比特币地址类型" aria-hidden="true">#</a> 比特币地址类型</h2><h3 id="_1-p2pkh-pay-to-public-key-hash" tabindex="-1"><a class="header-anchor" href="#_1-p2pkh-pay-to-public-key-hash" aria-hidden="true">#</a> 1. P2PKH（Pay to Public Key Hash）</h3><ul><li><strong>格式</strong>：以1开头。</li><li><strong>示例</strong>：<code>1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa</code></li><li><strong>描述</strong>：最常用的地址类型，支付到公钥哈希，使用标准的ECDSA签名。</li></ul><h3 id="_2-p2sh-pay-to-script-hash" tabindex="-1"><a class="header-anchor" href="#_2-p2sh-pay-to-script-hash" aria-hidden="true">#</a> 2. P2SH（Pay to Script Hash）</h3><ul><li><strong>格式</strong>：以3开头。</li><li><strong>示例</strong>：<code>3J98t1WpEZ73CNmQviecrnyiWrnqRhWNLy</code></li><li><strong>描述</strong>：支持复杂的脚本，比如多重签名，允许将支付发送到哈希化的脚本。</li></ul><h3 id="_3-p2wpkh-pay-to-witness-public-key-hash" tabindex="-1"><a class="header-anchor" href="#_3-p2wpkh-pay-to-witness-public-key-hash" aria-hidden="true">#</a> 3. P2WPKH（Pay to Witness Public Key Hash）</h3><ul><li><strong>格式</strong>：以bc1开头。</li><li><strong>示例</strong>：<code>bc1qw4q0a7p4j25r34f0h3v5fdqzg6a3lpe4q5ahkg</code></li><li><strong>描述</strong>：用于隔离见证（SegWit）交易，提供更低的交易费用和更好的隐私。</li></ul><h3 id="_4-p2wsh-pay-to-witness-script-hash" tabindex="-1"><a class="header-anchor" href="#_4-p2wsh-pay-to-witness-script-hash" aria-hidden="true">#</a> 4. P2WSH（Pay to Witness Script Hash）</h3><ul><li><strong>格式</strong>：以bc1开头。</li><li><strong>示例</strong>：<code>bc1qrk6prfuh7zkw0lj8dkz4xlqy6jq0p0f3zrgz6f</code></li><li><strong>描述</strong>：用于多重签名或复杂脚本的隔离见证支付。 址类型在比特币网络中都有其特定的应用场景，选择合适的地址类型可以提升交易效率和安全性。</li></ul><h1 id="比特币-一种点对点的电子现金系统" tabindex="-1"><a class="header-anchor" href="#比特币-一种点对点的电子现金系统" aria-hidden="true">#</a> 比特币：一种点对点的电子现金系统</h1><p>​ 作者：中本聪 ​ satoshin@gmx.com ​ www.bitcoin.org ​ 2008.10.31</p><p>​ 中文翻译：李笑来 ​ lixiaolai@gmail.com ​ 2018.10.31</p>`,37),k={href:"https://github.com/xiaolai/bitcoin-whitepaper-chinese-translation",target:"_blank",rel:"noopener noreferrer"},w=n('<blockquote><p><strong>Abstract.</strong> A purely peer-to-peer version of electronic cash would allow online payments to be sent directly from one party to another without going through a financial institution. Digital signatures provide part of the solution, but the main benefits are lost if a trusted third party is still required to prevent double-spending. We propose a solution to the double-spending problem using a peer-to-peer network. The network timestamps transactions by hashing them into an ongoing chain of hash-based proof-of-work, forming a record that cannot be changed without redoing the proof-of-work. The longest chain not only serves as proof of the sequence of events witnessed, but proof that it came from the largest pool of CPU power. As long as a majority of CPU power is controlled by nodes that are not cooperating to attack the network, they&#39;ll generate the longest chain and outpace attackers. The network itself requires minimal structure. Messages are broadcast on a best effort basis, and nodes can leave and rejoin the network at will, accepting the longest proof-of-work chain as proof of what happened while they were gone.</p><p><strong>概要</strong>：一个纯粹的点对点版本的电子现金系统，将允许在线支付直接从一方发送到另一方，而无需通过金融机构。数字签名虽然提供了部分解决方案，但，若是仍然需要被信任的第三方来防止双重支出的话，那么电子支付的主要优势就被抵消了。我们提出一个方案，使用点对点网络去解决双重支出问题。点对点网络将为每笔交易标记时间戳，方法是：把交易的散列数据录入一个不断延展的、以散列为基础的工作证明链上，形成一个如非完全重做就不可能改变的记录。最长链，一方面用来证明已被见证的事件及其顺序，与此同时，也用来证明它来自于最大的 CPU 算力池。只要绝大多数 CPU 算力被良性节点控制 —— 即，它们不与那些尝试攻击网络的节点合作 —— 那么，良性节点将会生成最长链，并且在速度上超过攻击者。这个网络本身需要最小化的结构。信息将以最大努力为基本去传播，节点来去自由；但，加入之时总是需要接受最长的工作证明链作为它们未参与期间所发生之一切的证明。</p></blockquote><hr><h2 id="_1-简介-introduction" tabindex="-1"><a class="header-anchor" href="#_1-简介-introduction" aria-hidden="true">#</a> 1. 简介 (Introduction)</h2><p>Commerce on the Internet has come to rely almost exclusively on financial institutions serving as trusted third parties to process electronic payments. While the system works well enough for most transactions, it still suffers from the inherent weaknesses of the trust based model. Completely non-reversible transactions are not really possible, since financial institutions cannot avoid mediating disputes. The cost of mediation increases transaction costs, limiting the minimum practical transaction size and cutting off the possibility for small casual transactions, and there is a broader cost in the loss of ability to make non-reversible payments for non-reversible services. With the possibility of reversal, the need for trust spreads. Merchants must be wary of their customers, hassling them for more information than they would otherwise need. A certain percentage of fraud is accepted as unavoidable. These costs and payment uncertainties can be avoided in person by using physical currency, but no mechanism exists to make payments over a communications channel without a trusted party.</p><p>互联网商业几乎完全依赖金融机构作为可信第三方去处理电子支付。虽然针对大多数交易来说，这个系统还算不错，但，它仍然被基于信任的模型所固有的缺陷所拖累。完全不可逆转的交易实际上并不可能，因为金融机构不能避免仲裁争议。仲裁成本增加了交易成本，进而限制了最小可能交易的规模，且干脆阻止了很多小额支付交易。除此之外，还有更大的成本：系统无法为那些不可逆的服务提供不可逆的支付。逆转的可能性，造成了对于信任的需求无所不在。商家必须提防着他们的顾客，麻烦顾客提供若非如此（如若信任）就并不必要的更多信息。一定比例的欺诈，被认为是不可避免的。这些成本和支付不确定性，虽然在人与人之间直接使用物理货币支付的时候是可以避免的；但，没有任何一个机制能在双方在其中一方不被信任的情况下通过沟通渠道进行支付。</p><p>What is needed is an electronic payment system based on cryptographic proof instead of trust, allowing any two willing parties to transact directly with each other without the need for a trusted third party. Transactions that are computationally impractical to reverse would protect sellers from fraud, and routine escrow mechanisms could easily be implemented to protect buyers. In this paper, we propose a solution to the double-spending problem using a peer-to-peer distributed timestamp server to generate computational proof of the chronological order of transactions. The system is secure as long as honest nodes collectively control more CPU power than any cooperating group of attacker nodes.</p><p>我们真正需要的是一种基于加密证明而非基于信任的电子支付系统，允许任意双方在不需要信任第三方的情况下直接交易。算力保障的不可逆转交易能帮助卖家不被欺诈，而保护买家的日常担保机制也很容易实现。在本论文中，我们将提出一种针对双重支出的解决方案，使用点对点的、分布式的时间戳服务器去生成基于算力的证明，按照时间顺序记录每条交易。此系统是安全的，只要诚实节点总体上相对于相互合作的攻击者掌握更多的 CPU 算力。</p><h2 id="_2-交易-transactions" tabindex="-1"><a class="header-anchor" href="#_2-交易-transactions" aria-hidden="true">#</a> 2. 交易 (Transactions)</h2><p>We define an electronic coin as a chain of digital signatures. Each owner transfers the coin to the next by digitally signing a hash of the previous transaction and the public key of the next owner and adding these to the end of the coin. A payee can verify the signatures to verify the chain of ownership.</p><p>我们将一枚电子硬币定义为一个数字签名链。一位所有者将一枚硬币交给另一个人的时候，要通过在这个数字签名链的末尾附加上以下数字签名：上一笔交易的哈希（hash，音译，亦翻译为“散列值”），以及新所有者的公钥。收款人可以通过验证签名去验证数字签名链的所属权。</p><p><img src="'+p+'" alt="" loading="lazy"></p><p>The problem of course is the payee can&#39;t verify that one of the owners did not double-spend the coin. A common solution is to introduce a trusted central authority, or mint, that checks every transaction for double spending. After each transaction, the coin must be returned to the mint to issue a new coin, and only coins issued directly from the mint are trusted not to be double-spent. The problem with this solution is that the fate of the entire money system depends on the company running the mint, with every transaction having to go through them, just like a bank.</p><p>这个路径的问题在于收款人无法验证曾经的所有者之中没有人双重支付过。常见的解决方案是引入一个可信的中心化权威方，或称“铸币厂”，让它去检查每一笔交易是否存在双重支付。每一次发生交易之后，硬币必须返回到铸币厂，铸币厂再发行一枚新的硬币。进而，只有铸币厂直接发行的硬币才是可信的、未被双重支付过的。这个解决方案的问题在于，整个货币系统的命运被拴在运营铸币厂的那个公司（就好像银行那样）身上，每一笔交易必须通过它。</p><p>We need a way for the payee to know that the previous owners did not sign any earlier transactions. For our purposes, the earliest transaction is the one that counts, so we don&#39;t care about later attempts to double-spend. The only way to confirm the absence of a transaction is to be aware of all transactions. In the mint based model, the mint was aware of all transactions and decided which arrived first. To accomplish this without a trusted party, transactions must be publicly announced[^1], and we need a system for participants to agree on a single history of the order in which they were received. The payee needs proof that at the time of each transaction, the majority of nodes agreed it was the first received.</p><p>我们需要一种方式，可以让收款人确认之前的所有者并没有在任何之前的交易上签名。就我们的目的而言，只有最早的交易是算数的，所以，我们并不关心其后的双重支付企图。确认一笔交易不存在的唯一方法是获悉所有的交易。在铸币厂模型之中，铸币厂已然知悉所有的交易，并且能够确认这些交易的顺序。为了能在没有“被信任的一方”参与的情况下完成以上任务，交易记录必须被公开宣布[^1]，进而我们需要一个系统能让参与者们认同它们所接收到的同一个唯一的交易历史。收款人需要证明在每笔交易发生之时，大多数节点能够认同它是第一个被接收的。</p><h2 id="_3-时间戳服务器-timestamp-server" tabindex="-1"><a class="header-anchor" href="#_3-时间戳服务器-timestamp-server" aria-hidden="true">#</a> 3. 时间戳服务器 (Timestamp Server)</h2><p>The solution we propose begins with a timestamp server. A timestamp server works by taking a hash of a block of items to be timestamped and widely publishing the hash, such as in a newspaper or Usenet post[^2] [^3] [^4] [^5]. The timestamp proves that the data must have existed at the time, obviously, in order to get into the hash. Each timestamp includes the previous timestamp in its hash, forming a chain, with each additional timestamp reinforcing the ones before it.</p><p>本解决方案起步于一种时间戳服务器。时间戳服务器是这样工作的：为一组（block）记录（items）的哈希打上时间戳，而后把哈希广播出去，就好像一份报纸所做的那样，或者像是在新闻组（Usenet）里的一个帖子那样[^2] [^3] [^4] [^5]。显然，时间戳能够证明那数据在那个时间点之前已然存在，否则那哈希也就无法生成。每个时间戳在其哈希中包含着之前的时间戳，因此构成了一个链；每一个新的时间戳被添加到之前的时间戳之后。</p><p><img src="'+h+'" alt="" loading="lazy"></p><h2 id="_4-工作证明-proof-of-work" tabindex="-1"><a class="header-anchor" href="#_4-工作证明-proof-of-work" aria-hidden="true">#</a> 4. 工作证明 (Proof-of-Work)</h2><p>To implement a distributed timestamp server on a peer-to-peer basis, we will need to use a proof-of-work system similar to Adam Back&#39;s Hashcash[^6], rather than newspaper or Usenet posts. The proof-of-work involves scanning for a value that when hashed, such as with SHA-256, the hash begins with a number of zero bits. The average work required is exponential in the number of zero bits required and can be verified by executing a single hash.</p><p>为了实现一个基于点对点的分布式时间戳服务器，我们需要使用类似亚当·伯克的哈希现金[^6]那样的一个工作证明系统，而不是报纸或者新闻组帖子那样的东西。所谓的工作证明，就是去寻找一个数值；这个数值要满足以下条件：为它提取散列数值之后 —— 例如使用 SHA-256 计算散列数值 —— 这个散列数值必须以一定数量的 0 开头。每增加一个 0 的要求，将使得工作量指数级增加，并且，这个工作量的验证却只需通过计算一个哈希。</p><p>For our timestamp network, we implement the proof-of-work by incrementing a nonce in the block until a value is found that gives the block&#39;s hash the required zero bits. Once the CPU effort has been expended to make it satisfy the proof-of-work, the block cannot be changed without redoing the work. As later blocks are chained after it, the work to change the block would include redoing all the blocks after it.</p><p>在我们的时间戳网络中，我们是这样实现工作证明的：不断在区块之中增加一个随机数（Nonce），直到一个满足条件的数值被找到；这个条件就是，这个区块的哈希以指定数量的 0 开头。一旦 CPU 的耗费算力所获的的结果满足工作证明，那么这个区块将不再能被更改，除非重新完成之前的所有工作量。随着新的区块不断被添加进来，改变当前区块即意味着说要重新完成所有其后区块的工作。</p><p><img src="'+m+'" alt="" loading="lazy"></p><p>The proof-of-work also solves the problem of determining representation in majority decision making. If the majority were based on one-IP-address-one-vote, it could be subverted by anyone able to allocate many IPs. Proof-of-work is essentially one-CPU-one-vote. The majority decision is represented by the longest chain, which has the greatest proof-of-work effort invested in it. If a majority of CPU power is controlled by honest nodes, the honest chain will grow the fastest and outpace any competing chains. To modify a past block, an attacker would have to redo the proof-of-work of the block and all blocks after it and then catch up with and surpass the work of the honest nodes. We will show later that the probability of a slower attacker catching up diminishes exponentially as subsequent blocks are added.</p><p>工作证明同时解决了如何决定谁能代表大多数做决定的问题。如果所谓的“大多数”是基于“一个IP地址一票”的方式决定的话，那么任何一个可以搞定很多 IP 地址的人就可以被认为是“大多数”。工作证明本质上来看，是“一个CPU一票”。所谓的“大多数决定”是由最长链所代表的，因为被投入最多工作的链就是它。如果大多数 CPU 算力被诚实的节点所控制，那么诚实链成长最为迅速，其速度会远超其他竞争链。为了更改一个已经产生的区块，攻击者将不得不重新完成那个区块以及所有其后区块的的工作证明，而后还要追上并超过诚实节点的工作。后文展示为什么一个被拖延了的攻击者能够追上的可能性将随着区块的不断增加而指数级降低。</p><p>To compensate for increasing hardware speed and varying interest in running nodes over time, the proof-of-work difficulty is determined by a moving average targeting an average number of blocks per hour. If they&#39;re generated too fast, the difficulty increases.</p><p>为了应对硬件算力综合的不断增加，以及随着时间推进可能产生的节点参与数量变化，工作证明难度由此决定：基于平均每小时产生的区块数量的一个移动平均值。如果区块生成得过快，那么难度将会增加。</p><h2 id="_5-网络-network" tabindex="-1"><a class="header-anchor" href="#_5-网络-network" aria-hidden="true">#</a> 5. 网络 (Network)</h2><p>The steps to run the network are as follows:</p><blockquote><ol><li>New transactions are broadcast to all nodes.</li><li>Each node collects new transactions into a block.</li><li>Each node works on finding a difficult proof-of-work for its block.</li><li>When a node finds a proof-of-work, it broadcasts the block to all nodes.</li><li>Nodes accept the block only if all transactions in it are valid and not already spent.</li><li>Nodes express their acceptance of the block by working on creating the next block in the chain, using the hash of the accepted block as the previous hash.</li></ol></blockquote><p>运行网络的步骤如下：</p><blockquote><ol><li>所有新的交易向所有节点广播；</li><li>每个节点将新交易打包到一个区块；</li><li>每个节点开始为此区块找一个具备难度的工作证明；</li><li>当某个区块找到其工作证明，它就要将此区块广播给所有节点；</li><li>众多其他节点当且只当以下条件满足才会接受这个区块：其中所有的交易都是有效的，且未被双重支付；</li><li>众多节点向网络表示自己接受这个区块的方法是，在创建下一个区块的时候，把被接受区块的哈希当作新区块之前的哈希。</li></ol></blockquote><p>Nodes always consider the longest chain to be the correct one and will keep working on extending it. If two nodes broadcast different versions of the next block simultaneously, some nodes may receive one or the other first. In that case, they work on the first one they received, but save the other branch in case it becomes longer. The tie will be broken when the next proof-of-work is found and one branch becomes longer; the nodes that were working on the other branch will then switch to the longer one.</p><p>节点始终认为最长链是正确的那个，且会不断向其添加新数据。若是有两个节点同时向网络广播了两个不同版本的“下一个区块”，有些节点会先接收到其中一个，而另外一些节点会先接收到另外一个。这种情况下，节点将在它们先接收到的那个区块上继续工作，但也会把另外一个分支保存下来，以防后者成为最长链。当下一个工作证明被找到，而其中的一个分支成为更长的链之后，这个暂时的分歧会被打消，在另外一个分支上工作的节点们会切换到更长的链上。</p><p>New transaction broadcasts do not necessarily need to reach all nodes. As long as they reach many nodes, they will get into a block before long. Block broadcasts are also tolerant of dropped messages. If a node does not receive a block, it will request it when it receives the next block and realizes it missed one.</p><p>新的交易不见得一定要广播到达所有的节点。只要到达足够多的节点，那么没多久这些交易就会被打包进一个区块。区块广播也容许一些消息被丢弃。如果一个节点并未接收到某个区块，那么这个节点会在它接收到下一个区块的时候意识到自己错失了之前的区块，因此会发出补充那个遗失区块的请求。</p><h2 id="_6-奖励-incentive" tabindex="-1"><a class="header-anchor" href="#_6-奖励-incentive" aria-hidden="true">#</a> 6. 奖励 (Incentive)</h2><p>By convention, the first transaction in a block is a special transaction that starts a new coin owned by the creator of the block. This adds an incentive for nodes to support the network, and provides a way to initially distribute coins into circulation, since there is no central authority to issue them. The steady addition of a constant of amount of new coins is analogous to gold miners expending resources to add gold to circulation. In our case, it is CPU time and electricity that is expended.</p><p>按照约定，每个区块的第一笔交易是一个特殊的交易，它会生成一枚新的硬币，所属权是这个区块的生成者。这么做，使得节点支持网络有所奖励，也提供了一种将硬币发行到流通之中的方式 —— 在这个系统中，反正也没有一个中心化的权威方去发行那些硬币。如此这般稳定地增加一定数量的新硬币进入流通，就好像是黄金开采者不断耗用他们的资源往流通之中增加黄金一样。在我们的系统中，被耗用的资源是 CPU 工作时间和它们所用的电力。</p><p>The incentive can also be funded with transaction fees. If the output value of a transaction is less than its input value, the difference is a transaction fee that is added to the incentive value of the block containing the transaction. Once a predetermined number of coins have entered circulation, the incentive can transition entirely to transaction fees and be completely inflation free.</p><p>奖励还可以来自交易费用。如果一笔交易的输出值小于它的输入值，那么其中的差额就是交易费；而该交易费就是用来奖励节点把该交易打包进此区块的。一旦既定数量的硬币已经进入流通，那么奖励将全面交由交易手续费来完成，且绝对不会有通货膨胀。</p><p>The incentive may help encourage nodes to stay honest. If a greedy attacker is able to assemble more CPU power than all the honest nodes, he would have to choose between using it to defraud people by stealing back his payments, or using it to generate new coins. He ought to find it more profitable to play by the rules, such rules that favour him with more new coins than everyone else combined, than to undermine the system and the validity of his own wealth.</p><p>奖励机制也可能会鼓励节点保持诚实。如果一个贪婪的攻击者能够网罗比所有诚实节点都更多的 CPU 算力，他必须做出一个选择：是用这些算力通过把自己花出去的钱偷回来去欺骗别人呢？还是用这些算力去生成新的硬币？他应该能够发现按照规则行事是更划算的，当前规则使得他能够获得比所有其他人加起来都更多的硬币，这显然比暗中摧毁系统并使自己的财富化为虚无更划算。</p><h2 id="_7-回收硬盘空间-reclaiming-disk-space" tabindex="-1"><a class="header-anchor" href="#_7-回收硬盘空间-reclaiming-disk-space" aria-hidden="true">#</a> 7. 回收硬盘空间 (Reclaiming Disk Space)</h2><p>Once the latest transaction in a coin is buried under enough blocks, the spent transactions before it can be discarded to save disk space. To facilitate this without breaking the block&#39;s hash, transactions are hashed in a Merkle Tree[^2][^5][^7], with only the root included in the block&#39;s hash. Old blocks can then be compacted by stubbing off branches of the tree. The interior hashes do not need to be stored.</p><p>如果一枚硬币最近发生的交易发生在足够多的区块之前，那么，这笔交易之前该硬币的花销交易记录可以被丢弃 —— 目的是为了节省磁盘空间。为了在不破坏该区块的哈希的前提下实现此功能，交易记录的哈希将被纳入一个 Merkle 树[^2][^5][^7]之中，而只有树根被纳入该区块的哈希之中。通过砍掉树枝方法，老区块即可被压缩。内部的哈希并不需要被保存。</p><p><img src="'+d+'" alt="" loading="lazy"></p><p>A block header with no transactions would be about 80 bytes. If we suppose blocks are generated every 10 minutes, 80 bytes * 6 * 24 * 365 = 4.2MB per year. With computer systems typically selling with 2GB of RAM as of 2008, and Moore&#39;s Law predicting current growth of 1.2GB per year, storage should not be a problem even if the block headers must be kept in memory.</p><p>一个没有任何交易记录的区块头大约是 80 个字节。假设每十分钟产生一个区块，80 字节乘以 6 乘以 24 乘以 365，等于每年 4.2M。截止 2008 年，大多数在售的计算机配有 2GB 内存，而按照摩尔定律的预测，每年会增加 1.2 GB，即便是区块头必须存储在内存之中也不会是什么问题。</p><h2 id="_8-简化版支付确认-simplified-payment-verification" tabindex="-1"><a class="header-anchor" href="#_8-简化版支付确认-simplified-payment-verification" aria-hidden="true">#</a> 8. 简化版支付确认 (Simplified Payment Verification)</h2><p>It is possible to verify payments without running a full network node. A user only needs to keep a copy of the block headers of the longest proof-of-work chain, which he can get by querying network nodes until he&#39;s convinced he has the longest chain, and obtain the Merkle branch linking the transaction to the block it&#39;s timestamped in. He can&#39;t check the transaction for himself, but by linking it to a place in the chain, he can see that a network node has accepted it, and blocks added after it further confirm the network has accepted it.</p><p>即便不用运行一个完整网络节点也有可能确认支付。用户只需要有一份拥有工作证明的最长链的区块头拷贝 —— 他可以通过查询在线节点确认自己拥有的确实来自最长链 —— 而后获取 Merkle 树的树枝节点，进而连接到这个区块被打上时间戳时的交易。用户并不能自己检查交易，但，通过连接到链上的某个地方，他可以看到某个网络节点已经接受了这个交易，而此后加进来的区块进一步确认了网络已经接受了此笔交易。</p><p><img src="'+u+'" alt="" loading="lazy"></p><p>As such, the verification is reliable as long as honest nodes control the network, but is more vulnerable if the network is overpowered by an attacker. While network nodes can verify transactions for themselves, the simplified method can be fooled by an attacker&#39;s fabricated transactions for as long as the attacker can continue to overpower the network. One strategy to protect against this would be to accept alerts from network nodes when they detect an invalid block, prompting the user&#39;s software to download the full block and alerted transactions to confirm the inconsistency. Businesses that receive frequent payments will probably still want to run their own nodes for more independent security and quicker verification.</p><p>只要诚实节点依然在掌控网络，如此这般，验证即为可靠的。然而，如果网络被攻击者所控制的时候，验证就没那么可靠了。尽管网络节点可以自己验证交易记录，但是，只要攻击者能够继续控制网络的话，那么简化版验证方式可能会被攻击者伪造的交易记录所欺骗。应对策略之一是，客户端软件要接受来自网络节点的警告。当网络节点发现无效区块的时候，即发出警报，在用户的软件上弹出通知，告知用户下载完整区块，警告用户确认交易一致性。那些有高频收付发生的商家应该仍然希望运行属于自己的完整节点，以此保证更独立的安全性和更快的交易确认。</p><h2 id="_9-价值的组合与分割-combining-and-splitting-value" tabindex="-1"><a class="header-anchor" href="#_9-价值的组合与分割-combining-and-splitting-value" aria-hidden="true">#</a> 9. 价值的组合与分割 (Combining and Splitting Value)</h2><p>Although it would be possible to handle coins individually, it would be unwieldy to make a separate transaction for every cent in a transfer. To allow value to be split and combined, transactions contain multiple inputs and outputs. Normally there will be either a single input from a larger previous transaction or multiple inputs combining smaller amounts, and at most two outputs: one for the payment, and one returning the change, if any, back to the sender.</p><p>尽管逐个地处理硬币是可能的，但为每分钱设置一个单独的记录是很笨拙的。为了允许价值的分割与合并，交易记录包含多个输入和输出。一般情况下，要么是一个单独的来自于一个相对大的之前的交易的输入，要么是很多个输入来自于更小金额的组合；与此同时，最多有两个输出：一个是支付（指向收款方），如果必要的话，另外一个是找零（指向发款方）。</p><p><img src="'+g+'" alt="" loading="lazy"></p><p>It should be noted that fan-out, where a transaction depends on several transactions, and those transactions depend on many more, is not a problem here. There is never the need to extract a complete standalone copy of a transaction&#39;s history.</p><p>值得注意的是，“扇出”在这里并不是问题 —— 所谓“扇出”，就是指一笔交易依赖于数笔交易，且这些交易又依赖于更多笔交易。从来就没有必要去提取任何一笔交易的完整独立的历史拷贝。</p><h2 id="_10-隐私-privacy" tabindex="-1"><a class="header-anchor" href="#_10-隐私-privacy" aria-hidden="true">#</a> 10. 隐私 (Privacy)</h2><p>The traditional banking model achieves a level of privacy by limiting access to information to the parties involved and the trusted third party. The necessity to announce all transactions publicly precludes this method, but privacy can still be maintained by breaking the flow of information in another place: by keeping public keys anonymous. The public can see that someone is sending an amount to someone else, but without information linking the transaction to anyone. This is similar to the level of information released by stock exchanges, where the time and size of individual trades, the &quot;tape&quot;, is made public, but without telling who the parties were.</p><p>传统的银行模型通过限制他人获取交易者和可信第三方的信息而达成一定程度的隐私保护。出于对将所有交易记录公开的需求否决了这种方法。但是，维持隐私可通过于另一处的切断信息流来实现——公钥匿名。公众可以看到某某向某某转账了一定的金额，但是，没有任何信息指向某个确定的人。这种水平的信息发布有点像股市交易，只有时间和各个交易的金额被公布，但是，没有人知道交易双方都是谁。</p><p><img src="'+y+'" alt="" loading="lazy"></p><p>As an additional firewall, a new key pair should be used for each transaction to keep them from being linked to a common owner. Some linking is still unavoidable with multi-input transactions, which necessarily reveal that their inputs were owned by the same owner. The risk is that if the owner of a key is revealed, linking could reveal other transactions that belonged to the same owner.</p><p>还有另外一层防火墙。交易者应该针对每一笔交易启用一对新的公私钥，以便他人无法将这些交易追溯到同一个所有者身上。有些多输入的交易依然难免被追溯，因为那些输入必然会被识别出来自于同一个所有者。危险在于，如果一个公钥的所有者被曝光之后，与之相关的所有其他交易都会被曝光。</p><h2 id="_11-计算-calculations" tabindex="-1"><a class="header-anchor" href="#_11-计算-calculations" aria-hidden="true">#</a> 11. 计算 (Calculations)</h2><p>We consider the scenario of an attacker trying to generate an alternate chain faster than the honest chain. Even if this is accomplished, it does not throw the system open to arbitrary changes, such as creating value out of thin air or taking money that never belonged to the attacker. Nodes are not going to accept an invalid transaction as payment, and honest nodes will never accept a block containing them. An attacker can only try to change one of his own transactions to take back money he recently spent.</p><p>假设一个场景，某个攻击者正在试图生成一个比诚实链更快的替代链。就算他成功了，也不能对系统做任意的修改，即，他不可能凭空制造出价值，也无法获取从未属于他的钱。网络节点不会把一笔无效交易当作支付，而诚实节点也永远不会接受一个包含这种支付的区块。攻击者最多只能修改属于他自己的交易，进而试图取回他已经花出去的钱。</p><p>The race between the honest chain and an attacker chain can be characterized as a Binomial Random Walk. The success event is the honest chain being extended by one block, increasing its lead by +1, and the failure event is the attacker&#39;s chain being extended by one block, reducing the gap by -1.</p>',73),z=s("p",null,[e("诚实链和攻击者之间的竞争可以用二项式随机漫步来描述。成功事件是诚实链刚刚被添加了一个新的区块，使得它的优势增加了 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mn",null,"1")]),s("annotation",{encoding:"application/x-tex"},"1")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"1")])])]),e("；而失败事件是攻击者的链刚刚被增加了一个新的区块，使得诚实链的优势减少了 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mn",null,"1")]),s("annotation",{encoding:"application/x-tex"},"1")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"1")])])]),e("。")],-1),x=s("p",null,"The probability of an attacker catching up from a given deficit is analogous to a Gambler's Ruin problem. Suppose a gambler with unlimited credit starts at a deficit and plays potentially an infinite number of trials to try to reach breakeven. We can calculate the probability he ever reaches breakeven, or that an attacker ever catches up with the honest chain, as follows[^8]:",-1),_=s("p",null,"攻击者能够从落后局面追平的概率类似于赌徒破产问题。假设，一个拿着无限筹码的赌徒，从亏空开始，允许他赌无限次，目标是填补上已有的亏空。我们能算出他最终能填补亏空的概率，也就是攻击者能够赶上诚实链的概率[^8]，如下：",-1),T=s("p",{class:"katex-block"},[s("span",{class:"katex-error",title:`ParseError: KaTeX parse error: No such environment: eqnarray* at position 8: 
\\begin{̲e̲q̲n̲a̲r̲r̲a̲y̲*̲}̲
      \\large p…`,style:{color:"#cc0000"}}," \\begin{eqnarray*} \\large p &=& \\text{ 诚实节点找到下一个区块的概率}\\\\ \\large q &=& \\text{ 攻击者找到下一个区块的概率}\\\\ \\large q_z &=& \\text{ 攻击者落后 $z$ 个区块却依然能够赶上的概率} \\end{eqnarray*} ")],-1),P=s("p",{class:"katex-block"},[s("span",{class:"katex-display"},[s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block"},[s("semantics",null,[s("mrow",null,[s("mstyle",{mathsize:"1.2em"},[s("msub",null,[s("mi",null,"q"),s("mi",null,"z")]),s("mo",null,"="),s("mrow",null,[s("mo",{fence:"true"},"{"),s("mtable",{rowspacing:"0.16em",columnalign:"center center",columnspacing:"1em"},[s("mtr",null,[s("mtd",null,[s("mstyle",{scriptlevel:"0",displaystyle:"false"},[s("mn",null,"1")])]),s("mtd",null,[s("mstyle",{scriptlevel:"0",displaystyle:"false"},[s("mrow",null,[s("mtext",{mathvariant:"italic"},"if"),s("mtext",null,"  "),s("mi",null,"p"),s("mo",null,"≤"),s("mi",null,"q")])])])]),s("mtr",null,[s("mtd",null,[s("mstyle",{scriptlevel:"0",displaystyle:"false"},[s("mrow",null,[s("mo",{stretchy:"false"},"("),s("mi",null,"q"),s("mi",{mathvariant:"normal"},"/"),s("mi",null,"p"),s("msup",null,[s("mo",{stretchy:"false"},")"),s("mi",null,"z")])])])]),s("mtd",null,[s("mstyle",{scriptlevel:"0",displaystyle:"false"},[s("mrow",null,[s("mtext",{mathvariant:"italic"},"if"),s("mtext",null,"  "),s("mi",null,"p"),s("mo",null,">"),s("mi",null,"q")])])])])]),s("mo",{fence:"true"},"}")])])]),s("annotation",{encoding:"application/x-tex"}," \\large q_z = \\begin{Bmatrix} 1 & \\textit{if}\\; p \\leq q\\\\ (q/p)^z & \\textit{if}\\; p > q \\end{Bmatrix} ")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.75em","vertical-align":"-0.2333em"}}),s("span",{class:"mord sizing reset-size6 size7"},[s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"q"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.137em"}},[s("span",{style:{top:"-2.65em","margin-left":"-0.0359em","margin-right":"0.0417em"}},[s("span",{class:"pstrut",style:{height:"2.8em"}}),s("span",{class:"sizing reset-size7 size4 mtight"},[s("span",{class:"mord mathnormal mtight",style:{"margin-right":"0.04398em"}},"z")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel sizing reset-size6 size7"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"3em","vertical-align":"-1.19em"}}),s("span",{class:"minner sizing reset-size6 size7"},[s("span",{class:"mopen sizing reset-size7 size6 delimcenter",style:{top:"-0.05em"}},[s("span",{class:"delimsizing size4"},"{")]),s("span",{class:"mord"},[s("span",{class:"mtable"},[s("span",{class:"col-align-c"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"1.45em"}},[s("span",{style:{top:"-3.81em"}},[s("span",{class:"pstrut",style:{height:"3.2em"}}),s("span",{class:"mord"},[s("span",{class:"mord"},"1")])]),s("span",{style:{top:"-2.61em"}},[s("span",{class:"pstrut",style:{height:"3.2em"}}),s("span",{class:"mord"},[s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"q"),s("span",{class:"mord"},"/"),s("span",{class:"mord mathnormal"},"p"),s("span",{class:"mclose"},[s("span",{class:"mclose"},")"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.65em"}},[s("span",{style:{top:"-3.163em","margin-right":"0.0417em"}},[s("span",{class:"pstrut",style:{height:"2.8em"}}),s("span",{class:"sizing reset-size7 size4 mtight"},[s("span",{class:"mord mathnormal mtight",style:{"margin-right":"0.04398em"}},"z")])])])])])])])])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.95em"}},[s("span")])])])]),s("span",{class:"arraycolsep",style:{width:"0.5em"}}),s("span",{class:"arraycolsep",style:{width:"0.5em"}}),s("span",{class:"col-align-c"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"1.45em"}},[s("span",{style:{top:"-3.81em"}},[s("span",{class:"pstrut",style:{height:"3.2em"}}),s("span",{class:"mord"},[s("span",{class:"mord text"},[s("span",{class:"mord textit"},"if")]),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mord mathnormal"},"p"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"≤"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"q")])]),s("span",{style:{top:"-2.61em"}},[s("span",{class:"pstrut",style:{height:"3.2em"}}),s("span",{class:"mord"},[s("span",{class:"mord text"},[s("span",{class:"mord textit"},"if")]),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mord mathnormal"},"p"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},">"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"q")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.95em"}},[s("span")])])])])])]),s("span",{class:"mclose sizing reset-size7 size6 delimcenter",style:{top:"-0.05em"}},[s("span",{class:"delimsizing size4"},"}")])])])])])])],-1),q=s("p",null,[e("Given our assumption that "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"p"),s("mo",null,">"),s("mi",null,"q"),s("mtext",null,"​")]),s("annotation",{encoding:"application/x-tex"},"p \\gt q​")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7335em","vertical-align":"-0.1944em"}}),s("span",{class:"mord mathnormal"},"p"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},">"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.625em","vertical-align":"-0.1944em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"q"),s("span",{class:"mord"},"​")])])]),e(", the probability drops exponentially as the number of blocks the attacker has to catch up with increases. With the odds against him, if he doesn't make a lucky lunge forward early on, his chances become vanishingly small as he falls further behind.")],-1),C=s("p",null,[e("既然我们已经假定 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"p"),s("mo",null,">"),s("mi",null,"q")]),s("annotation",{encoding:"application/x-tex"},"p > q")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7335em","vertical-align":"-0.1944em"}}),s("span",{class:"mord mathnormal"},"p"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},">"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.625em","vertical-align":"-0.1944em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"q")])])]),e(", 既然攻击者需要赶超的区块数量越来越多，那么其成功概率就会指数级下降。于赢面不利时，如果攻击者没有在起初就能幸运地向前猛跨一步，那么他的胜率将在他进一步落后的同时消弭殆尽。")],-1),U=s("p",null,"We now consider how long the recipient of a new transaction needs to wait before being sufficiently certain the sender can't change the transaction. We assume the sender is an attacker who wants to make the recipient believe he paid him for a while, then switch it to pay back to himself after some time has passed. The receiver will be alerted when that happens, but the sender hopes it will be too late.",-1),M=s("p",null,"现在考虑一下一笔新交易的收款人需要等多久才能充分确定发款人不能更改这笔交易。我们假定发款人是个攻击者，妄图让收款人在一段时间里相信他已经支付对付款项，随后将这笔钱再转回给自己。发生这种情况时，收款人当然会收到警告，但发款人希望那时木已成舟。",-1),S=s("p",null,"The receiver generates a new key pair and gives the public key to the sender shortly before signing. This prevents the sender from preparing a chain of blocks ahead of time by working on it continuously until he is lucky enough to get far enough ahead, then executing the transaction at that moment. Once the transaction is sent, the dishonest sender starts working in secret on a parallel chain containing an alternate version of his transaction.",-1),O=s("p",null,"收款人生成了一对新的公私钥，而后在签署之前不久将公钥告知发款人。这样可以防止一种情形：发款人提前通过连续运算去准备一条链上的区块，并且只要有足够的运气就会足够领先，直到那时再执行交易。一旦款项已被发出，那个不诚实的发款人开始秘密地在另一条平行链上开工，试图在其中加入一个反向版本的交易。",-1),A=s("p",null,[e("The recipient waits until the transaction has been added to a block and "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"z")]),s("annotation",{encoding:"application/x-tex"},"z")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.04398em"}},"z")])])]),e(" blocks have been linked after it. He doesn't know the exact amount of progress the attacker has made, but assuming the honest blocks took the average expected time per block, the attacker's potential progress will be a Poisson distribution with expected value:")],-1),B=s("p",null,[e("收款人等到此笔交易被打包进区块，并已经有 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"z")]),s("annotation",{encoding:"application/x-tex"},"z")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.04398em"}},"z")])])]),e(" 个区块随后被加入。他并不知道攻击者的工作进展究竟如何，但是可以假定诚实区块在每个区块生成过程中耗费的平均时间；攻击者的潜在进展符合泊松分布，其期望值为：")],-1),I=s("p",{class:"katex-block"},[s("span",{class:"katex-display"},[s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block"},[s("semantics",null,[s("mrow",null,[s("mstyle",{mathsize:"1.2em"},[s("mi",null,"λ"),s("mo",null,"="),s("mi",null,"z"),s("mfrac",null,[s("mi",null,"q"),s("mi",null,"p")])])]),s("annotation",{encoding:"application/x-tex"}," \\large \\lambda = z \\frac qp ")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8333em"}}),s("span",{class:"mord mathnormal sizing reset-size6 size7"},"λ"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel sizing reset-size6 size7"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"2.3856em","vertical-align":"-1.0565em"}}),s("span",{class:"mord mathnormal sizing reset-size6 size7",style:{"margin-right":"0.04398em"}},"z"),s("span",{class:"mord sizing reset-size6 size7"},[s("span",{class:"mopen nulldelimiter sizing reset-size7 size6"}),s("span",{class:"mfrac"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"1.1076em"}},[s("span",{style:{top:"-2.514em"}},[s("span",{class:"pstrut",style:{height:"3.2em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"p")])]),s("span",{style:{top:"-3.43em"}},[s("span",{class:"pstrut",style:{height:"3.2em"}}),s("span",{class:"frac-line",style:{"border-bottom-width":"0.04em"}})]),s("span",{style:{top:"-3.877em"}},[s("span",{class:"pstrut",style:{height:"3.2em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"q")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8804em"}},[s("span")])])])]),s("span",{class:"mclose nulldelimiter sizing reset-size7 size6"})])])])])])],-1),W=s("p",null,"To get the probability the attacker could still catch up now, we multiply the Poisson density for each amount of progress he could have made by the probability he could catch up from that point:",-1),H=s("p",null,"为了算出攻击者依然可以赶上的概率，我们要把攻击者需要追赶的区块数目的帕松分布概率密度，乘以在落后该区块数目下能够追上来的概率：",-1),X=s("p",{class:"katex-block"},[s("span",{class:"katex-display"},[s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block"},[s("semantics",null,[s("mrow",null,[s("mstyle",{mathsize:"1.2em"},[s("munderover",null,[s("mo",null,"∑"),s("mrow",null,[s("mi",null,"k"),s("mo",null,"="),s("mn",null,"0")]),s("mi",{mathvariant:"normal"},"∞")]),s("mfrac",null,[s("mrow",null,[s("msup",null,[s("mi",null,"λ"),s("mi",null,"k")]),s("msup",null,[s("mi",null,"e"),s("mrow",null,[s("mo",null,"−"),s("mi",null,"λ")])])]),s("mrow",null,[s("mi",null,"k"),s("mo",{stretchy:"false"},"!")])]),s("mo",null,"⋅"),s("mrow",null,[s("mo",{fence:"true"},"{"),s("mtable",{rowspacing:"0.16em",columnalign:"center center",columnspacing:"1em"},[s("mtr",null,[s("mtd",null,[s("mstyle",{scriptlevel:"0",displaystyle:"false"},[s("mrow",null,[s("mo",{stretchy:"false"},"("),s("mi",null,"q"),s("mi",{mathvariant:"normal"},"/"),s("mi",null,"p"),s("msup",null,[s("mo",{stretchy:"false"},")"),s("mrow",null,[s("mo",{stretchy:"false"},"("),s("mi",null,"z"),s("mo",null,"−"),s("mi",null,"k"),s("mo",{stretchy:"false"},")")])])])])]),s("mtd",null,[s("mstyle",{scriptlevel:"0",displaystyle:"false"},[s("mrow",null,[s("mtext",{mathvariant:"italic"},"if"),s("mtext",null,"  "),s("mi",null,"k"),s("mo",null,"≤"),s("mi",null,"z")])])])]),s("mtr",null,[s("mtd",null,[s("mstyle",{scriptlevel:"0",displaystyle:"false"},[s("mn",null,"1")])]),s("mtd",null,[s("mstyle",{scriptlevel:"0",displaystyle:"false"},[s("mrow",null,[s("mtext",{mathvariant:"italic"},"if"),s("mtext",null,"  "),s("mi",null,"k"),s("mo",null,">"),s("mi",null,"z")])])])])]),s("mo",{fence:"true"},"}")])])]),s("annotation",{encoding:"application/x-tex"}," \\large \\sum_{k=0}^{\\infty} \\frac{\\lambda^k e^{-\\lambda}}{k!} \\cdot \\begin{Bmatrix} (q/p)^{(z-k)} & \\textit{if}\\;k\\leq z\\\\ 1 & \\textit{if} \\; k > z \\end{Bmatrix} ")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"3.4992em","vertical-align":"-1.5348em"}}),s("span",{class:"mop op-limits sizing reset-size6 size7"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"1.637em"}},[s("span",{style:{top:"-2.021em","margin-left":"0em"}},[s("span",{class:"pstrut",style:{height:"3.2em"}}),s("span",{class:"sizing reset-size7 size4 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mathnormal mtight",style:{"margin-right":"0.03148em"}},"k"),s("span",{class:"mrel mtight"},"="),s("span",{class:"mord mtight"},"0")])])]),s("span",{style:{top:"-3.2em"}},[s("span",{class:"pstrut",style:{height:"3.2em"}}),s("span",null,[s("span",{class:"mop op-symbol large-op"},"∑")])]),s("span",{style:{top:"-4.45em","margin-left":"0em"}},[s("span",{class:"pstrut",style:{height:"3.2em"}}),s("span",{class:"sizing reset-size7 size4 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mtight"},"∞")])])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"1.279em"}},[s("span")])])])]),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord sizing reset-size6 size7"},[s("span",{class:"mopen nulldelimiter sizing reset-size7 size6"}),s("span",{class:"mfrac"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"1.503em"}},[s("span",{style:{top:"-2.514em"}},[s("span",{class:"pstrut",style:{height:"3.2em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal",style:{"margin-right":"0.03148em"}},"k"),s("span",{class:"mclose"},"!")])]),s("span",{style:{top:"-3.43em"}},[s("span",{class:"pstrut",style:{height:"3.2em"}}),s("span",{class:"frac-line",style:{"border-bottom-width":"0.04em"}})]),s("span",{style:{top:"-3.877em"}},[s("span",{class:"pstrut",style:{height:"3.2em"}}),s("span",{class:"mord"},[s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"λ"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.826em"}},[s("span",{style:{top:"-3.163em","margin-right":"0.0417em"}},[s("span",{class:"pstrut",style:{height:"2.8em"}}),s("span",{class:"sizing reset-size7 size4 mtight"},[s("span",{class:"mord mathnormal mtight",style:{"margin-right":"0.03148em"}},"k")])])])])])])]),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"e"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.826em"}},[s("span",{style:{top:"-3.163em","margin-right":"0.0417em"}},[s("span",{class:"pstrut",style:{height:"2.8em"}}),s("span",{class:"sizing reset-size7 size4 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mtight"},"−"),s("span",{class:"mord mathnormal mtight"},"λ")])])])])])])])])])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.686em"}},[s("span")])])])]),s("span",{class:"mclose nulldelimiter sizing reset-size7 size6"})]),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin sizing reset-size6 size7"},"⋅"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"3em","vertical-align":"-1.19em"}}),s("span",{class:"minner sizing reset-size6 size7"},[s("span",{class:"mopen sizing reset-size7 size6 delimcenter",style:{top:"-0.05em"}},[s("span",{class:"delimsizing size4"},"{")]),s("span",{class:"mord"},[s("span",{class:"mtable"},[s("span",{class:"col-align-c"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"1.4615em"}},[s("span",{style:{top:"-3.7985em"}},[s("span",{class:"pstrut",style:{height:"3.2em"}}),s("span",{class:"mord"},[s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"q"),s("span",{class:"mord"},"/"),s("span",{class:"mord mathnormal"},"p"),s("span",{class:"mclose"},[s("span",{class:"mclose"},")"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.863em"}},[s("span",{style:{top:"-3.163em","margin-right":"0.0417em"}},[s("span",{class:"pstrut",style:{height:"2.8em"}}),s("span",{class:"sizing reset-size7 size4 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mopen mtight"},"("),s("span",{class:"mord mathnormal mtight",style:{"margin-right":"0.04398em"}},"z"),s("span",{class:"mbin mtight"},"−"),s("span",{class:"mord mathnormal mtight",style:{"margin-right":"0.03148em"}},"k"),s("span",{class:"mclose mtight"},")")])])])])])])])])])]),s("span",{style:{top:"-2.5985em"}},[s("span",{class:"pstrut",style:{height:"3.2em"}}),s("span",{class:"mord"},[s("span",{class:"mord"},"1")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.9615em"}},[s("span")])])])]),s("span",{class:"arraycolsep",style:{width:"0.5em"}}),s("span",{class:"arraycolsep",style:{width:"0.5em"}}),s("span",{class:"col-align-c"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"1.4615em"}},[s("span",{style:{top:"-3.7985em"}},[s("span",{class:"pstrut",style:{height:"3.2em"}}),s("span",{class:"mord"},[s("span",{class:"mord text"},[s("span",{class:"mord textit"},"if")]),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03148em"}},"k"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"≤"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.04398em"}},"z")])]),s("span",{style:{top:"-2.5985em"}},[s("span",{class:"pstrut",style:{height:"3.2em"}}),s("span",{class:"mord"},[s("span",{class:"mord text"},[s("span",{class:"mord textit"},"if")]),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03148em"}},"k"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},">"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.04398em"}},"z")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.9615em"}},[s("span")])])])])])]),s("span",{class:"mclose sizing reset-size7 size6 delimcenter",style:{top:"-0.05em"}},[s("span",{class:"delimsizing size4"},"}")])])])])])])],-1),L=s("p",null,"Rearranging to avoid summing the infinite tail of the distribution...",-1),N=s("p",null,"为了避免对密度分布的无穷级数求和重新整理…",-1),D=s("p",{class:"katex-block"},[s("span",{class:"katex-display"},[s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block"},[s("semantics",null,[s("mrow",null,[s("mstyle",{mathsize:"1.2em"},[s("mn",null,"1"),s("mo",null,"−"),s("munderover",null,[s("mo",null,"∑"),s("mrow",null,[s("mi",null,"k"),s("mo",null,"="),s("mn",null,"0")]),s("mi",null,"z")]),s("mfrac",null,[s("mrow",null,[s("msup",null,[s("mi",null,"λ"),s("mi",null,"k")]),s("msup",null,[s("mi",null,"e"),s("mrow",null,[s("mo",null,"−"),s("mi",null,"λ")])])]),s("mrow",null,[s("mi",null,"k"),s("mo",{stretchy:"false"},"!")])]),s("mrow",null,[s("mo",{fence:"true"},"("),s("mn",null,"1"),s("mo",null,"−"),s("mo",{stretchy:"false"},"("),s("mi",null,"q"),s("mi",{mathvariant:"normal"},"/"),s("mi",null,"p"),s("msup",null,[s("mo",{stretchy:"false"},")"),s("mrow",null,[s("mo",{stretchy:"false"},"("),s("mi",null,"z"),s("mo",null,"−"),s("mi",null,"k"),s("mo",{stretchy:"false"},")")])]),s("mo",{fence:"true"},")")])])]),s("annotation",{encoding:"application/x-tex"}," \\large 1 - \\sum_{k=0}^{z} \\frac{\\lambda^k e^{-\\lambda}}{k!} \\left ( 1-(q/p)^{(z-k)} \\right ) ")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8733em","vertical-align":"-0.1em"}}),s("span",{class:"mord sizing reset-size6 size7"},"1"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin sizing reset-size6 size7"},"−"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"3.4992em","vertical-align":"-1.5348em"}}),s("span",{class:"mop op-limits sizing reset-size6 size7"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"1.637em"}},[s("span",{style:{top:"-2.021em","margin-left":"0em"}},[s("span",{class:"pstrut",style:{height:"3.2em"}}),s("span",{class:"sizing reset-size7 size4 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mathnormal mtight",style:{"margin-right":"0.03148em"}},"k"),s("span",{class:"mrel mtight"},"="),s("span",{class:"mord mtight"},"0")])])]),s("span",{style:{top:"-3.2em"}},[s("span",{class:"pstrut",style:{height:"3.2em"}}),s("span",null,[s("span",{class:"mop op-symbol large-op"},"∑")])]),s("span",{style:{top:"-4.45em","margin-left":"0em"}},[s("span",{class:"pstrut",style:{height:"3.2em"}}),s("span",{class:"sizing reset-size7 size4 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mathnormal mtight",style:{"margin-right":"0.04398em"}},"z")])])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"1.279em"}},[s("span")])])])]),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord sizing reset-size6 size7"},[s("span",{class:"mopen nulldelimiter sizing reset-size7 size6"}),s("span",{class:"mfrac"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"1.503em"}},[s("span",{style:{top:"-2.514em"}},[s("span",{class:"pstrut",style:{height:"3.2em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal",style:{"margin-right":"0.03148em"}},"k"),s("span",{class:"mclose"},"!")])]),s("span",{style:{top:"-3.43em"}},[s("span",{class:"pstrut",style:{height:"3.2em"}}),s("span",{class:"frac-line",style:{"border-bottom-width":"0.04em"}})]),s("span",{style:{top:"-3.877em"}},[s("span",{class:"pstrut",style:{height:"3.2em"}}),s("span",{class:"mord"},[s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"λ"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.826em"}},[s("span",{style:{top:"-3.163em","margin-right":"0.0417em"}},[s("span",{class:"pstrut",style:{height:"2.8em"}}),s("span",{class:"sizing reset-size7 size4 mtight"},[s("span",{class:"mord mathnormal mtight",style:{"margin-right":"0.03148em"}},"k")])])])])])])]),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"e"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.826em"}},[s("span",{style:{top:"-3.163em","margin-right":"0.0417em"}},[s("span",{class:"pstrut",style:{height:"2.8em"}}),s("span",{class:"sizing reset-size7 size4 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mtight"},"−"),s("span",{class:"mord mathnormal mtight"},"λ")])])])])])])])])])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.686em"}},[s("span")])])])]),s("span",{class:"mclose nulldelimiter sizing reset-size7 size6"})]),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"minner sizing reset-size6 size7"},[s("span",{class:"mopen sizing reset-size7 size6 delimcenter",style:{top:"-0.05em"}},[s("span",{class:"delimsizing size2"},"(")]),s("span",{class:"mord"},"1"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"−"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"q"),s("span",{class:"mord"},"/"),s("span",{class:"mord mathnormal"},"p"),s("span",{class:"mclose"},[s("span",{class:"mclose"},")"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.913em"}},[s("span",{style:{top:"-3.213em","margin-right":"0.0417em"}},[s("span",{class:"pstrut",style:{height:"2.8em"}}),s("span",{class:"sizing reset-size7 size4 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mopen mtight"},"("),s("span",{class:"mord mathnormal mtight",style:{"margin-right":"0.04398em"}},"z"),s("span",{class:"mbin mtight"},"−"),s("span",{class:"mord mathnormal mtight",style:{"margin-right":"0.03148em"}},"k"),s("span",{class:"mclose mtight"},")")])])])])])])])]),s("span",{class:"mclose sizing reset-size7 size6 delimcenter",style:{top:"-0.05em"}},[s("span",{class:"delimsizing size2"},")")])])])])])])],-1),E=n(`<p>Converting to C code...</p><p>转换为 C 语言程序……</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;math.h&gt;</span></span>
<span class="token keyword">double</span> <span class="token function">AttackerSuccessProbability</span><span class="token punctuation">(</span><span class="token keyword">double</span> q<span class="token punctuation">,</span> <span class="token keyword">int</span> z<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">double</span> p <span class="token operator">=</span> <span class="token number">1.0</span> <span class="token operator">-</span> q<span class="token punctuation">;</span>
	<span class="token keyword">double</span> lambda <span class="token operator">=</span> z <span class="token operator">*</span> <span class="token punctuation">(</span>q <span class="token operator">/</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">double</span> sum <span class="token operator">=</span> <span class="token number">1.0</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> i<span class="token punctuation">,</span> k<span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> z<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token keyword">double</span> poisson <span class="token operator">=</span> <span class="token function">exp</span><span class="token punctuation">(</span><span class="token operator">-</span>lambda<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> k<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
			poisson <span class="token operator">*=</span> lambda <span class="token operator">/</span> i<span class="token punctuation">;</span>
		sum <span class="token operator">-=</span> poisson <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> <span class="token function">pow</span><span class="token punctuation">(</span>q <span class="token operator">/</span> p<span class="token punctuation">,</span> z <span class="token operator">-</span> k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> sum<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,3),j=s("p",null,[e("Running some results, we can see the probability drop off exponentially with "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"z")]),s("annotation",{encoding:"application/x-tex"},"z")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.04398em"}},"z")])])]),e(".")],-1),K=s("p",null,[e("获取部分结果，我们可以看到概率随着 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"z")]),s("annotation",{encoding:"application/x-tex"},"z")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.04398em"}},"z")])])]),e(" 的增加指数级下降：")],-1),R=n(`<div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>   q=0.1
   z=0    P=1.0000000
   z=1    P=0.2045873
   z=2    P=0.0509779
   z=3    P=0.0131722
   z=4    P=0.0034552
   z=5    P=0.0009137
   z=6    P=0.0002428
   z=7    P=0.0000647
   z=8    P=0.0000173
   z=9    P=0.0000046
   z=10   P=0.0000012
   
   q=0.3
   z=0    P=1.0000000
   z=5    P=0.1773523
   z=10   P=0.0416605
   z=15   P=0.0101008
   z=20   P=0.0024804
   z=25   P=0.0006132
   z=30   P=0.0001522
   z=35   P=0.0000379
   z=40   P=0.0000095
   z=45   P=0.0000024
   z=50   P=0.0000006
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Solving for P less than 0.1%...</p><p>若是 P 小于 0.1%……</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>   P &lt; 0.001
   q=0.10   z=5
   q=0.15   z=8
   q=0.20   z=11
   q=0.25   z=15
   q=0.30   z=24
   q=0.35   z=41
   q=0.40   z=89
   q=0.45   z=340
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_12-结论-conclusion" tabindex="-1"><a class="header-anchor" href="#_12-结论-conclusion" aria-hidden="true">#</a> 12. 结论 (Conclusion)</h2><p>We have proposed a system for electronic transactions without relying on trust. We started with the usual framework of coins made from digital signatures, which provides strong control of ownership, but is incomplete without a way to prevent double-spending. To solve this, we proposed a peer-to-peer network using proof-of-work to record a public history of transactions that quickly becomes computationally impractical for an attacker to change if honest nodes control a majority of CPU power. The network is robust in its unstructured simplicity. Nodes work all at once with little coordination. They do not need to be identified, since messages are not routed to any particular place and only need to be delivered on a best effort basis. Nodes can leave and rejoin the network at will, accepting the proof-of-work chain as proof of what happened while they were gone. They vote with their CPU power, expressing their acceptance of valid blocks by working on extending them and rejecting invalid blocks by refusing to work on them. Any needed rules and incentives can be enforced with this consensus mechanism.</p><p>我们提出了一个不必依赖信任的电子交易系统；起点是一个普通的使用数字签名的硬币框架开始，虽然它提供了健壮的所有权控制，却无法避免双重支付。为了解决这个问题，我们提出一个使用工作证明机制的点对点网络去记录一个公开的交易记录历史，只要诚实节点能够控制大多数 CPU 算力，那么攻击者就仅从算力方面就不可能成功篡改系统。这个网络的健壮在于它的无结构的简单。节点们可以在很少协同的情况下瞬间同时工作。它们甚至不需要被辨认，因为消息的路径并非取决于特定的终点；消息只需要被以最大努力为基本去传播即可。节点来去自由，重新加入时，只需要接受工作证明链，作为它们离线之时所发生之一切的证明。它们通过它们的 CPU 算力投票，通过不断为链添加新的有效区块、拒绝无效区块，去表示它们对有效交易的接受与否。任何必要的规则和奖励都可以通过这个共识机制来强制实施。</p><hr><h2 id="参考文献-references" tabindex="-1"><a class="header-anchor" href="#参考文献-references" aria-hidden="true">#</a> 参考文献 (References)</h2>`,9),G=s("strong",null,"b-money",-1),V={href:"http://www.weidai.com/bmoney.txt",target:"_blank",rel:"noopener noreferrer"},F=s("strong",null,"Design of a secure timestamping service with minimal trust requirements",-1),J=s("em",null,"20th Symposium on Information Theory in the Benelux",-1),Q={href:"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.13.6228",target:"_blank",rel:"noopener noreferrer"},$=s("strong",null,"How to time-stamp a digital document",-1),Y=s("em",null,"Journal of Cryptology",-1),Z={href:"https://doi.org/cwwxd4",target:"_blank",rel:"noopener noreferrer"},ss={href:"https://doi.org/10.1007/bf00196791",target:"_blank",rel:"noopener noreferrer"},es=s("strong",null,"Improving the Efficiency and Reliability of Digital Time-Stamping",-1),as=s("em",null,"Sequences II",-1),ts={href:"https://doi.org/bn4rpx",target:"_blank",rel:"noopener noreferrer"},ns={href:"https://doi.org/10.1007/978-1-4613-9323-8_24",target:"_blank",rel:"noopener noreferrer"},is=s("strong",null,"Secure names for bit-strings",-1),ls=s("em",null,"Proceedings of the 4th ACM conference on Computer and communications security - CCS ’97",-1),os={href:"https://doi.org/dtnrf6",target:"_blank",rel:"noopener noreferrer"},rs={href:"https://doi.org/10.1145/266420.266430",target:"_blank",rel:"noopener noreferrer"},cs=s("strong",null,"Hashcash - A Denial of Service Counter-Measure",-1),ps={href:"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.15.8",target:"_blank",rel:"noopener noreferrer"},hs=s("strong",null,"Protocols for Public Key Cryptosystems",-1),ms=s("em",null,"1980 IEEE Symposium on Security and Privacy",-1),ds={href:"https://doi.org/bmvbd6",target:"_blank",rel:"noopener noreferrer"},us={href:"https://doi.org/10.1109/sp.1980.10006",target:"_blank",rel:"noopener noreferrer"},gs=s("strong",null,"An Introduction to Probability Theory and its Applications",-1),ys=s("em",null,"John Wiley & Sons",-1),bs={href:"https://archive.org/details/AnIntroductionToProbabilityTheoryAndItsApplicationsVolume1",target:"_blank",rel:"noopener noreferrer"};function fs(vs,ks){const l=i("DocsAD"),t=i("ExternalLinkIcon");return r(),c("div",null,[f,a(l),v,s("p",null,[e("​ "),s("a",k,[e("Checkout Github Repo for this translation"),a(t)])]),w,z,x,_,T,P,q,C,U,M,S,O,A,B,I,W,H,X,L,N,D,E,j,K,R,s("p",null,[e("[^1]: "),G,e(" Dai Wei (1998-11-01) "),s("a",V,[e("http://www.weidai.com/bmoney.txt"),a(t)]),e(" [^2]: "),F,e(" Henri Massias, Xavier Serret-Avila, Jean-Jacques Quisquater "),J,e(" (1999-05) "),s("a",Q,[e("http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.13.6228"),a(t)]),e(" [^3]: "),$,e(" Stuart Haber, W.Scott Stornetta "),Y,e(" (1991) "),s("a",Z,[e("https://doi.org/cwwxd4"),a(t)]),e(" DOI: "),s("a",ss,[e("10.1007/bf00196791"),a(t)]),e(" [^4]: "),es,e(" Dave Bayer, Stuart Haber, W. Scott Stornetta "),as,e(" (1993) "),s("a",ts,[e("https://doi.org/bn4rpx"),a(t)]),e(" DOI: "),s("a",ns,[e("10.1007/978-1-4613-9323-8_24"),a(t)]),e(" [^5]: "),is,e(" Stuart Haber, W. Scott Stornetta "),ls,e("(1997) "),s("a",os,[e("https://doi.org/dtnrf6"),a(t)]),e(" DOI: "),s("a",rs,[e("10.1145/266420.266430"),a(t)]),e(" [^6]: "),cs,e(" Adam Back (2002-08-01) "),s("a",ps,[e("http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.15.8"),a(t)]),e(" [^7]: "),hs,e(" Ralph C. Merkle "),ms,e(" (1980-04) "),s("a",ds,[e("https://doi.org/bmvbd6"),a(t)]),e(" DOI: "),s("a",us,[e("10.1109/sp.1980.10006"),a(t)]),e(" [^8]: "),gs,e(" William Feller "),ys,e(" (1957) "),s("a",bs,[e("https://archive.org/details/AnIntroductionToProbabilityTheoryAndItsApplicationsVolume1"),a(t)])])])}const zs=o(b,[["render",fs],["__file","theory.html.vue"]]);export{zs as default};
